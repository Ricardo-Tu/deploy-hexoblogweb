---
title: 植物大战僵尸自动启动恢复小推车
sticky: false
comments: true
toc: true
toc_number: true
mathjax: false
highlight_shrink: false
aside: true
copyright: false
date: 2024-08-17 12:00:00
updated:
tags: vulkan 
categories:
keywords: vulkan
description:
cover: 10.png
top_img: /media/top_img.jpg
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
---

天气太热了，工地的砖头今天格外的烫手，白天在工地搬砖，工地对面的小卖部冰箱里的雪糕是我遥不可及的梦。晚上回家，没有空调的加持，风扇的风出啦也是热风，还是先讲今天的教程吧。

1. 小推车触发条件，僵尸在小推车前面，说明小推车触发需要僵尸所在行数这个参数
2. 一共有5、6个小推车，僵尸在哪行就会触发哪行的推车，所以小推车大概率存放在一个数组里面，数组的成员结构体存放的是小推车的状态
3. 需要找到小推车function call

```c
// 小推车的状态
小推车消失并恢复 = 0
小推车静止 = 1
小推车运动 = 2
小推车消失 = 3
```

# 首先寻找小推车的状态
1. 在选择植物时，搜索未知的初始值
![](1.png)

2. 选择好植物，开始游戏后，看见小推车全部恢复后，搜索改变的数值
![](2.png)

3. 随意做一些动作，打开图鉴，等待僵尸出现，收集阳光，种植植物等，只要不发动小推车，就搜索未变动的数值，过滤掉其他不相关数据
![](3.png)

4. 让僵尸走到小推车前，触发小推车，让小推车发动，暂停游戏并搜索改变的数值
![](4.png)

5. 搜索一次变动的数值之后，因为小推车一直处于运动中，所以回到游戏，再暂停游戏我们都得搜所未变动的数值
![](5.png)

6. 因为保存小推车的状态这种数据肯定是小的数据，所以可以用小于10小于100大于-10大于-100等大致范围过滤一些不合理的超大数据
![](6.png)

7. 将所有数据全部拉入修改列表中，然后尝试修改数值为0等，观察小推车状态是否有变化，可以看到，在修改为0之后，小推车先消失，然后又恢复
![](7.png)

8. 然后重复修改表中的数据，大致的排除删除数据，最后锁定小推车状态是在哪个数据中，最后只有一个数值，这个数值就是保存了这两
![](8.png)

# 定位发动小推车的函数调用位置
1. 找到这个地址之后，打开x32dbg,然后attach到植物大战僵尸游戏，接着跳转到这个地址处并设置内存写入断点，有硬件写入和软件写入两种，随意哪种都可以
![](9.png)
如果中途错了就重新搜索

2. 我设置的是硬件写入断点，断在这个位置，所以是上一条指令修改了这个地址的值
![](10.png)

3. 可以大胆推测在这个函数中基本就是和小推车发动或者修改其状态相关的函数，或者在上一级函数中，可以通过查看函数调用堆栈跳转到上一级函数
![](11.png)

4. 定位到上一级函数位置
![](12.png)

5. 我们查看这个调用的两个参数一个存放在esi中一个存放在eax中，所以可以重开游戏然后重新触发断点，然后观察其中数据的变化，观察其中是否有什么规律或者是存放着是僵尸的结构体或者是小推车的结构体，这里我分别触发了0-4行的小推车并记录了这esi，ebp寄存器在这5次触发过程中的数值

![](13.png)

```bash

esi 0r:18A6DF54  1r:18A6DF54  2r:18A6DF54  3r:18A6DF54  4r:18A6DC9C
ebp 0r:18860ED8  1r:18860F20  2r:18860F68  3r:18860FB0  4r:18860FF8

```

观察可以看到esi寄存器没有什么规律，ebp的规律就很明显，相邻的数据都相差0x48，这就是小推车的结构体数据数组，是指针还是结构体还需要再分析。

接着利用CE搜索到ebp的指针偏移为

```c++
// 接着利用CE搜索到ebp的指针偏移为
[[[base_ptr + 0x2a9ec0] + 0x768] + 0x100]
```


# 实现
1. 构造调用函数启动小推车函数的桩函数

```asm
// 创建远程线程执行的函数
    60                       | pushad                                  |
    68 44332211              | push 11223344                           |
    BA A08D4500              | mov edx,458DA0                          |
    FFD2                     | call edx                                |
    61                       | popad                                   |
    C3                       | ret                                     |
// 将小推车走远后停止修改为小推车走远后自动恢复
    C647 30 00               | mov byte ptr ds:[edi+30],0              |
```

2. 调用函数远程执行构造的桩函数
```c++
HANDLE hRemoteThread = CreateRemoteThread(g_crack->stGameInfo->hGame,
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)pRemoteBuffer,
    pRemoteThreadParam,
    0,
    NULL
);
```

3. 执行完成后就能启动小推车

# 过程
![](14.svg)
实现代码：
[链接](https://github.com/Ricardo-Tu/ApplicationExtension)

