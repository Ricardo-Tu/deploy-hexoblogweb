---
title: 游戏修改器(一)瞬移
sticky: false
comments: true
toc: true
toc_number: true
mathjax: false
highlight_shrink: false
aside: true
copyright: false
date: 2022-04-07 12:00:05
updated:
tags: games
categories:
keywords:
description:
cover: 13.png
top_img: /media/20.jpg
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
---

# 一、概述

第一次尝试写游戏修改器教程，有些忐忑，纠结了好久，不知道写什么游戏好，最后决定找一个二十年前的老游戏，比较简单，很容易上手。游戏修改器的知识都是和内存、汇编这些相关，而这些知识也算是比较枯燥的了。我希望出这样的一些教程，能够激起大家学习内存相关知识的兴趣。第一次写这样的文章，希望大家能够看懂理解并自己实现吧。

最后只想再说一句：游戏修改器最基础的概念就是内存，一切操作都是基于内存！！！

# 二、工具

- Cheat Engine 7.2

- x32dbg

- Visual Studio 2019

- 使用Windows MFC开发

# 三、实现步骤

我们知道，在cs1.6这个FPS游戏中，每个人物的定位都是由坐标定位的，这个通常都是为笛卡尔坐标系。所以首先需要找到人物的坐标位置。

- 搜索人物坐标
  1. 首先模糊搜索float型未知的初始值（开始不知道是什么类型时，把整形、float、double都尝试就能找到）

    ![](1.png)

  2. 设置搜索快捷键，这个设置成自己习惯的按键(若和游戏按键冲突会造成不太方便)。

    ![](2.png)

  3. 在游戏中平地上随意走动，鼠标随意晃动，搜索未变动的数值，跳跃搜索变动的数值，落地后再搜索一次变动的数值，接着搜索未变动的数值。重复上述步骤，直到无法再排除。

    ![](3.png)

    删除上面的绿色地址，这些为静态地址，首先排除。接着将剩余的地址添加到地址列表，将其一条条锁定，最后能够寻找到两个地址锁定后人物无法跳跃。其中一个地址存放的为z坐标增量，另一个地址存放的为z坐标的值，被锁定后人物都无法跳跃。

    ![](4.png)

    查看相关内存可知x y z的坐标和x y z轴增量。

    ![](5.png)

    附：这是一个动态地址，在重启游戏后会申请地址，所以需要找到它的指针映射集。使用指针扫描功能，重启游戏，重新找到人物坐标，就能找到它的指针和偏移。(注意指针扫描功能保存的文件夹和文件名都不能有中文)最后找到的大部分都可以使用。通过重复的读取内存加偏移的方式能够访问x y z坐标。这个步骤在瞬移的实现中并没有使用，下次使用并介绍其他功能时候再做介绍。

     ![](6.png)

  4. 接着找出是什么访问了该指针指向的地址  

    ![](7.png)

  5. 查看每一条所在汇编程序，查看指令所访问的地址。这一处指令是只访问我们坐标的指令。

   ![](8.png)

- Inline Hook

  1. 使用Inline Hook，在此处修改程序执行的流程。

    被修改指令：

    ```bash
        D8 40 10            - fadd st(0),dword ptr ds:[eax+10]

        D9 CA               - fxch st(0),st(2)

        8B 44 24 04         - mov eax,dword ptr ss:[esp+4]
    ```

    跳转指令：(使用了6个字节，覆盖了三条指令，跳转回的地址为三条指令后的地址)

    ![](9.png)

  1. 设置标志位，并设置全局快捷键，当按下某个键时保存当前位置，当移动到某个位置时，按下另一个全局快捷键，瞬移到保存的位置。我的是实现为按下F8 设置一个标志位，跳转到上述地址处，通过[eax+0x8]、[eax+0xc]、[eax+0x10]访问x、y、z坐标并保存，当按下F9时，设置另一个标志位，判断标志位，若被置位，则加载保存的地址，实现瞬移。

    我设置这个标志位是搜索很多0的数据，搜索到后调用VirtualProtectEx函数修改页面属性为可读可写可执行，这些地址用来存储标志位和我们保存的地址。

    ![](10.png)
    
  2. 使用x32dbg 完成Flag的判断并保存和加载人物坐标的汇编代码。

   ![](11.png)

  3. 将上述shellcode放入目标地址，使用跳转指令覆盖原指令并跳转到此处，在这段shellcode后面添加跳转回被覆盖指令的下一条指令的地址处。

    ![](12.png)

    调试上述程序，中断查看局部变量，pRemoteBuf为cs1.6进程申请的地址(跨进程申请内存)。

    ![](13.png)

  4. 查看cs1.6游戏中，中断到被修改指令处。

    ![](14.png)

  5. 跟踪进入pRemoteBuf,单步调试

   ![](15.png)

  6. 最后返回到了 mp.dll + 8E8C4。

   ![](16.png)

  7. 按下 F8 ，查看目标内存地址，成功储存了当前人物坐标。

   ![](17.png)

  8. 人物随意移动到一个地点，按下 F9 ，人物瞬移到储存的位置。成功！

   ![](18.png)

# 四、总结

最后，一张图总结实现思路：

![](19.png)

最后附上我的视频介绍：

链接 ：[百度网盘](https://pan.baidu.com/s/1DKo3U-egKD5RUg4otegMkw?_at_=1701624839172)

提取码 ：P46A 

由于各种原因已经好久没有更新过文章了，本来早就打算出几篇游戏修改器的教程，由于需要写毕业论文、找工作等各种原因，一直没有完成，光这篇文章我就硬憋了两天才完成。希望能给大家学习指针内存等知识带来一些兴趣吧。学习之路太过漫长，每次学一些新知识，我就想着学完这些应该能成够入门了，学完才知道，自己还差得远呢，接下来会了解的新的知识我又会产生相同的想法，不知道猴年马月我才能入门啊。我也经常在论坛看网上的高手分享技术，属实羡慕，我也不指望能成为一个高手了，只期望成为一个中手吧(中国之手，国家之手) 哈哈哈。有空我还会继续出修改器的其他功能，总之，希望大家能够看懂这一章节并完成自己的修改器。

**学习过程中还有很多不足，还望朋友们指正！**
